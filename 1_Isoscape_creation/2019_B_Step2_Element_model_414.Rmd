---
title: "Full area/time pull data together"
output: html_document
editor_options: 
  chunk_output_type: console
---


# Setup
```{r setup}
# Reset R's brain
rm(list=ls())
# getwd tells us where R is looking
getwd()
# setwd tells R where to look
setwd('F:/R_script/Microchemistry/elemental_maps')
#setwd("/Volumes/PHD/R_script/SDM/full_area_time")
getwd()

############################## libraries #####################################################
library(gamm4)
library(fields)
library(KernSmooth)
library(GISTools)
library(SDMTools)
library(maps)
library(mapdata)
library(RgoogleMaps)
library(PBSmapping)
library(plyr)
library(raster)
library(rgdal)
library(spatial.tools)
library(RColorBrewer)
library(rgeos)
library(AID)
library(gamclass)
library(cvTools)
library(spatstat)
library(ggplot2)
library(fitdistrplus)
library(caret)


source("sdm_functions.R")
source("F:/R_script/Microchemistry/elemental_maps/soap_checker/soap_check.R")

####################################### map extents ########################################################

###### FULL EXTENT ___________ -10 to -3, 52 to 60 c(xmin, xmax, ymin, ymax)
###### SCOT EXTENT ___________ -10 to  -4, 52 to 55
###### Chem Full Extent____________ -9 to -3, 52 to 59
###### chem scot extent ___________ -9 to -4, 55 to 59
###extents for later
full.ext<- extent(c(-10, -2, 52, 60))
scot.ext<- extent(c(-10, -4, 55, 60))
chemfull.ext<- extent(c(-9, -3, 52, 59))
chemscot.ext<- extent(c(-9, -4, 55, 59))


################################## coord system to assign ####################################################
WGS84<- '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'
#### projection
mrc <- '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs'



################################# basic background maps of land and sea #####################################

#### use shape files generated from 'make_extentshp' code use rgdal to read it in to get projections
#scot<- readOGR(dsn="/Volumes/PHD/R_script/SDM", layer="scot")
base<- readOGR(dsn='F:/R_script/SDM', layer="full")
# base<- readOGR(dsn='/Volumes/PHD/R_script/SDM', layer="full")

plot(base)
base<- crop(base, full.ext)

land<- readOGR(dsn= "F:/R_script/SDM/my_layers_collection", layer ='Britain_Proj_Dist')
#land<- readOGR(dsn= "/Volumes/PHD/R_script/SDM/my_layers_collection", layer ='Britain_Proj_Dist')
land<- spTransform(land, CRS(WGS84))
land<- crop(land, full.ext)


plot(base, col ='cornflowerblue')
plot(land, col='cornsilk', add=T)

###################################
### apply projection to sea area and land from above
landT<- spTransform(land, CRS(mrc))
baseT<- spTransform(base, CRS(mrc))

```

# Element data
```{r}

dat<- read.csv('F:/R_script/Microchemistry/elemental_maps/chem2017_Tidy.csv')


#dat<- subset(dat, dat$use=='y')
summary(dat$Area)
max(dat$Pit_no)
min(dat$Pit_no)
# subset for the time points we want
# and get the edge data
edge<- subset(dat, dat$Reverse_pit_no=='1')
edge<- droplevels(edge)
str(edge)
edge$Mn_0<- as.numeric(as.character(edge$Mn_0))



ed4.14<- subset(edge, edge$sample_time ==4.14)
ed4.14<- droplevels(ed4.14)

table(ed4.14$Haul_id)
sum(as.vector(table(ed4.14$Haul_id)))
table(ed4.14$Sex)
table(ed4.14$use)
ed4.14<- subset(ed4.14, ed4.14$use == 'y')

#make sure we are looking at the correct months


##### 4.14
summary(ed4.14$Sample_months)
summary(ed4.14$pred_month)

## remove ones which are way too early
#try with out this look at element spread in graphs
#ed4.14<- subset(ed4.14, ed4.14$pred_month != 'Aug' & ed4.14$pred_month != 'Jul')


summary(ed4.14$pred_month)
ed4.14<- droplevels(ed4.14)

# Go through each element in turn, check for normality
# 
#Na

hist(ed4.14$Na)
shapiro.test(ed4.14$Na)  ##Normal
qqnorm(ed4.14$Na); qqline(ed4.14$Na, col = 2)

# 
# # growth relationship
# plot(Na~Dist_to_pit, data=ed4.14)
# lineNa<- lm(Na~Dist_to_pit, data=ed4.14) ##  not-Sig
# summary(lineNa)
# abline(lineNa)


chem<- data.frame('ID'= ed4.14$ID, 'Na'=ed4.14$Na)


#Mg
hist(ed4.14$Mg)
shapiro.test(ed4.14$Mg)  ##Normal
qqnorm(ed4.14$Mg); qqline(ed4.14$Mg, col = 2)

# 
# plot(Mg~Dist_to_pit, data=ed4.14)
# lineMg<- lm(Mg~Dist_to_pit, data=ed4.14) ## non-Sig
# summary(lineMg)
# abline(lineMg)

chem<- cbind(chem, 'Mg'=ed4.14$Mg)


#P
hist(ed4.14$P)
shapiro.test(ed4.14$P)  ##Normal
qqnorm(ed4.14$P); qqline(ed4.14$P, col = 2)

# 
# 
# plot(P~Dist_to_pit, data=ed4.14)
# lineP<- lm(P~Dist_to_pit, data=ed4.14) ## Non - Sig
# summary(lineP)

chem<- cbind(chem, 'P'=ed4.14$P)

#Ba
summary(ed4.14$Ba)
hist(ed4.14$Ba)
shapiro.test(ed4.14$Ba)  ##Non-Normal
qqnorm(ed4.14$Ba); qqline(ed4.14$Ba, col = 2)

#what distrobution
hist(ed4.14$Ba)
descdist(ed4.14$Ba, boot=500)
f<-fitdistr(ed4.14$Ba, 'gamma')
plotdist(ed4.14$Ba, distr='gamma', para=list(shape=1.6, rate=0.5))
rate.est<- mean(ed4.14$Ba)/var(ed4.14$Ba)
rate.est
shape.est<- (mean(ed4.14$Ba)^2)/var(ed4.14$Ba)
shape.est
plotdist(ed4.14$Ba, distr='gamma', para=list(shape=shape.est, rate=rate.est))

chem<- cbind(chem, 'Ba'=ed4.14$Ba)


#Sr

hist(ed4.14$Sr)
shapiro.test(ed4.14$Sr)  ##Normal
qqnorm(ed4.14$Sr); qqline(ed4.14$Sr, col = 2)

# 
# 
# plot(Sr~Dist_to_pit, data=ed4.14)
# lineSr<- lm(Sr~Dist_to_pit, data=ed4.14) ## not Sig
# summary(lineSr)
# abline(lineSr)


chem<- cbind(chem, 'Sr'=ed4.14$Sr)

#Mn 0
summary(ed4.14$Mn)

hist(ed4.14$Mn_0)
shapiro.test(ed4.14$Mn_0)  ##Non-Normal
qqnorm(ed4.14$Mn_0); qqline(ed4.14$Mn_0, col = 2)

#what distrobution
hist(ed4.14$Mn_0+0.1)
descdist(ed4.14$Mn_0+0.1, boot=500)
f<-fitdistr(ed4.14$Mn_0+0.1, 'gamma')
plotdist(ed4.14$Mn_0+0.1, distr='gamma', para=list(shape=1.5, rate=0.6))
rate.est<- mean(ed4.14$Mn_0+0.1)/var(ed4.14$Mn_0+0.1)
rate.est
shape.est<- (mean(ed4.14$Mn_0+0.1)^2)/var(ed4.14$Mn_0+0.1)
shape.est
plotdist(ed4.14$Mn_0+0.1, distr='gamma', para=list(shape=shape.est, rate=rate.est))

chem<- cbind(chem, 'Mn'=ed4.14$Mn_0+0.1)


#Zn 
summary(ed4.14$Zn)

hist(ed4.14$Zn)
shapiro.test(ed4.14$Zn)  ##Non-Normal
qqnorm(ed4.14$Zn); qqline(ed4.14$Zn, col = 2)

#normalise
Znout<- boxcoxnc(ed4.14$Zn)
ZnT<-Znout$tf.data
shapiro.test(ZnT)
qqnorm(ZnT); qqline(ZnT, col = 2)   ##not Normal
hist(ZnT)

# 
# plot(Zn~Dist_to_pit, data=ed4.14)
# lineZn<- lm(Zn~Dist_to_pit, data=ed4.14) ## not Sig
# summary(lineZn)
# abline(lineZn)


chem<- cbind(chem, 'Zn'=ed4.14$Zn)

((0.032424^-0.38)-1)/-0.38# box cox transformation used on measurement error


#Ni
summary(ed4.14$Ni)

hist(ed4.14$Ni)
shapiro.test(ed4.14$Ni)  ##Non-Normal
qqnorm(ed4.14$Ni); qqline(ed4.14$Ni, col = 2)

#normalise
Niout<- boxcoxnc(ed4.14$Ni)
NiT<-Niout$tf.data
shapiro.test(NiT)
qqnorm(NiT); qqline(NiT, col = 2)   ## not - Normal
hist(NiT)

# 
# plot(Ni~Dist_to_pit, data=ed4.14)
# lineNi<- lm(Ni~Dist_to_pit, data=ed4.14) ## Sig
# summary(lineNi)
# abline(lineNi)
# 
# # corect for length
# 
# NiCor<- lineNi$residuals
# 
# hist(NiCor)
# shapiro.test(NiCor)  ##not Normal
# qqnorm(NiCor); qqline(NiCor, col = 2)


chem<- cbind(chem, 'Ni'=ed4.14$Ni)

#Cu
summary(ed4.14$Cu)

hist(ed4.14$Cu)
shapiro.test(ed4.14$Cu)  ##Non-Normal
qqnorm(ed4.14$Cu); qqline(ed4.14$Cu, col = 2)

#normalise
Cuout<- boxcoxnc(ed4.14$Cu) 
CuT<-Cuout$tf.data
shapiro.test(CuT)
qqnorm(CuT); qqline(CuT, col = 2)   ## Normal
hist(CuT)

# 
# plot(CuT~Dist_to_pit, data=ed4.14)
# lineCuT<- lm(CuT~Dist_to_pit, data=ed4.14) ## non Sig
# summary(lineCuT)
# abline(lineCuT)



chem<- cbind(chem, 'Cu'=CuT)






#Rb
summary(ed4.14$Rb)

hist(ed4.14$Rb)
shapiro.test(ed4.14$Rb)  ##Non-Normal
qqnorm(ed4.14$Rb); qqline(ed4.14$Rb, col = 2)

#normalise
Rbout<- boxcoxnc(ed4.14$Rb)
RbT<-Rbout$tf.data
shapiro.test(RbT)
qqnorm(RbT); qqline(RbT, col = 2)   ##not- Normal
hist(RbT)
# 
# 
# plot(Rb~Dist_to_pit, data=ed4.14)
# lineRb<- lm(Rb~Dist_to_pit, data=ed4.14) ## non Sig
# summary(lineRb)
# abline(lineRb)

#what distrobution
hist(ed4.14$Rb)
descdist(ed4.14$Rb, boot=500)
f<-fitdistr(ed4.14$Rb, 'gamma')
plotdist(ed4.14$Rb, distr='gamma', para=list(shape=4.5, rate=70.7))
rate.est<- mean(ed4.14$Rb)/var(ed4.14$Rb)
rate.est
shape.est<- (mean(ed4.14$Rb)^2)/var(ed4.14$Rb)
shape.est
plotdist(ed4.14$Rb, distr='gamma', para=list(shape=shape.est, rate=rate.est))
chem<- cbind(chem, 'Rb'=ed4.14$Rb)

 
#Cr_0
summary(ed4.14$Cr)

hist(ed4.14$Cr)
shapiro.test(ed4.14$Cr)  ##Non-Normal
qqnorm(ed4.14$Cr); qqline(ed4.14$Cr, col = 2)

#normalise
Crout<- boxcoxnc(ed4.14$Cr)   ##non Normal

# 
# 
# plot(Cr~Dist_to_pit, data=ed4.14)
# lineCr<- lm(Cr~Dist_to_pit, data=ed4.14) ## non Sig
# summary(lineCr)
# abline(lineCr)


chem<- cbind(chem, 'Cr'=ed4.14$Cr)

#Li
summary(ed4.14$Li)

hist(ed4.14$Li+1)
shapiro.test(ed4.14$Li)  ##Non-Normal
qqnorm(ed4.14$Li); qqline(ed4.14$Li, col = 2)

#normalise
Liout<- boxcoxnc(ed4.14$Li)   ##non Normal

# 
# 
# plot(Li~Dist_to_pit, data=ed4.14)
# lineLi<- lm(Li~Dist_to_pit, data=ed4.14) ## non -Sig
# summary(lineLi)
# abline(lineLi)

#what distrobution
hist(ed4.14$Li)
descdist(ed4.14$Li+1, boot=500)
f<-fitdistr(ed4.14$Li+1, 'gamma')
f
plotdist(ed4.14$Li+1, distr='gamma', para=list(shape=29.27, rate=21.53))

rate.est<- mean(ed4.14$Li+1)/var(ed4.14$Li+1)
rate.est
shape.est<- (mean(ed4.14$Li+1)^2)/var(ed4.14$Li+1)
shape.est
plotdist(ed4.14$Li+1, distr='gamma', para=list(shape=shape.est, rate=rate.est))

chem<- cbind(chem, 'Li'=ed4.14$Li+1)


#Al &0
summary(ed4.14$Al)

hist(ed4.14$Al_0)
shapiro.test(ed4.14$Al_0)  ##Non-Normal
qqnorm(ed4.14$Al_0); qqline(ed4.14$Al_0, col = 2)

#normalise
Alout<- boxcoxnc(ed4.14$Al_0+1) ## non Normal

# 
# plot(Al_0~Dist_to_pit, data=ed4.14)
# lineAl<- lm(Al_0~Dist_to_pit, data=ed4.14) ## Sig
# summary(lineAl)
# abline(lineAl)


chem<- cbind(chem, 'Al'=ed4.14$Al_0)


#Sc &0
summary(ed4.14$Sc)


hist(ed4.14$Sc_0+1)
shapiro.test(ed4.14$Sc_0)  ##Non-Normal
qqnorm(ed4.14$Sc_0); qqline(ed4.14$Sc_0, col = 2)

#normalise
Scout<- boxcoxnc(ed4.14$Sc_0+1)   ## non Normal

# 
# plot(Sc_0~Dist_to_pit, data=ed4.14)
# lineSc<- lm(Sc_0~Dist_to_pit, data=ed4.14) ## not Sig
# summary(lineSc)
# abline(lineSc)

#what distrobution
hist(exp(ed4.14$Sc_0))
hist(ed4.14$Sc_0+1)
#ed4.14$Sc_0<- exp(ed4.14$Sc_0)

descdist(ed4.14$Sc_0+1, boot=500)
f<-fitdistr(ed4.14$Sc_0+1, 'gamma')
f
plotdist(ed4.14$Sc_0+1, distr='gamma', para=list(shape=3935, rate= 3861))

rate.est<- mean(ed4.14$Sc_0+1)/var(ed4.14$Sc_0+1)
rate.est
shape.est<- (mean(ed4.14$Sc_0+1)^2)/var(ed4.14$Sc_0+1)
shape.est
#plotdist(exp(ed4.14$Sc_0), distr='gamma', demp=T, para=list(shape=shape.est, rate=rate.est))

plotdist(ed4.14$Sc_0+1, distr='gamma', demp=F, para=list(shape=shape.est, rate=rate.est))


chem<- cbind(chem, 'Sc'=ed4.14$Sc_0+1)

#Ti &0
summary(ed4.14$Ti)

hist(ed4.14$Ti_0)
shapiro.test(ed4.14$Ti_0)  ##Non-Normal
qqnorm(ed4.14$Ti_0); qqline(ed4.14$Ti_0, col = 2)

#normalise
Tiout<- boxcoxnc(ed4.14$Ti_0+1)##non Normal

# 
# plot(Ti~Dist_to_pit, data=ed4.14)
# lineTi<- lm(Ti~Dist_to_pit, data=ed4.14) ## non Sig
# summary(lineTi)
# abline(lineTi)


chem<- cbind(chem, 'Ti'=ed4.14$Ti_0)

#Y &0
summary(ed4.14$Y)


hist(ed4.14$Y_0)
shapiro.test(ed4.14$Y_0)  ##Non-Normal
qqnorm(ed4.14$Y_0); qqline(ed4.14$Y_0, col = 2)

#normalise
Yout<- boxcoxnc(ed4.14$Y_0+1) ## non Normal
# 
# plot(Y_0~Dist_to_pit, data=ed4.14)
# lineY<- lm(Y_0~Dist_to_pit, data=ed4.14) ## non Sig
# summary(lineY)
# abline(lineY)


chem<- cbind(chem, 'Y'=ed4.14$Y_0)

#Pb &0
summary(ed4.14$Pb)

hist(ed4.14$Pb_0)
shapiro.test(ed4.14$Pb_0)  ##Non-Normal
qqnorm(ed4.14$Pb_0); qqline(ed4.14$Pb_0, col = 2)

#normalise
Pbout<- boxcoxnc(ed4.14$Pb_0+1) ## non Normal

# 
# plot(Pb_0~Dist_to_pit, data=ed4.14)
# linePb<- lm(Pb_0~Dist_to_pit, data=ed4.14) ## Sig
# summary(linePb)
# abline(linePb)


chem<- cbind(chem, 'Pb'=ed4.14$Pb_0)

head(chem)
summary(chem)
str(chem)
names(ed4.14)

# remove the outlier from previously
chem<- chem[-57,]
ed4.14<- ed4.14[-57,]

# bind some other useful stuff
chem<- cbind(chem, 'Area'= ed4.14$Area, 'Haul_id'= as.numeric(as.factor(ed4.14$Haul_id)), 'radius' = ed4.14$Dist_to_pit, 'long'= ed4.14$Mid_long, 'lat'= ed4.14$Mid_lat, 'HaulF'= as.factor(ed4.14$Haul_id))

```


# Spatial variation
```{r}

# look for wiggly spatial relationships and relationships with groups - only need to do these elements

#Na
line<- gam(Na~s(long, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)

line<- gam(Na~s(lat, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


A<- aov(Na~ HaulF, data=chem)
summary(A)
TukeyHSD(A)$HaulF # include Na

# Mg
line<- gam(Mg~s(long, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Mg~s(lat, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


A<- aov(Mg~ HaulF, data=chem)
summary(A)
TukeyHSD(A)$HaulF # include Mg

# P
line<- gam(P~s(long, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(P~s(lat, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


A<- aov(P~ HaulF, data=chem)
summary(A)
TukeyHSD(A)$HaulF # don't include P


# Ba
line<- gam(Ba~s(long, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Ba~s(lat, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

kruskal.test(Ba~ HaulF, data=chem) # include Ba


# Sr
line<- gam(Sr~s(long, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Sr~s(lat, k=4), data=chem)
summary(line)
plot(line, residuals=T, cex=4)


A<- aov(Sr~ HaulF, data=chem)
summary(A)
TukeyHSD(A)$HaulF # include Sr

# Mn
line<- gam(Mn~s(long, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Mn~s(lat, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


A<- aov(Mn~ HaulF, data=chem)
summary(A)
TukeyHSD(A)$HaulF # include Mn



# Rb
line<- gam(Rb~s(long, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Rb~s(lat, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


kruskal.test(Rb~ HaulF, data=chem) #include Rb


# Sc
line<- gam(Sc~s(long, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Sc~s(lat, k=4), data=chem, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


kruskal.test(Sc~ HaulF, data=chem) # dont include Sc


names(chem)
#chem<- chem[,-c(4, 8,9,12,14:18)] # drop P, Zn, Ni, Cr, Al, Ti, Y, Pb

write.csv(chem, file = 'F:/R_script/Microchemistry/elemental_maps/chem414.csv')

par(mfrow=c(1,1))
```





# make elements sp object
```{r}

coords.tmp<- cbind(chem$long, chem$lat)
## create spdf object
chem.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(chem),
                                   proj4string = CRS(WGS84))

#### trim biological layers to fit extent
chem.spdfT<- crop(chem.spdf, full.ext)
chem.spdfT<- spTransform(chem.spdfT, CRS(mrc))


###plot to see abundances

### 
plot(baseT)
choropleth(chem.spdfT, chem$Na, pch=19, cex = 1.4, main = 'non-transformed data', add=T)
plot(chem.spdfT, pch=1, add=T, cex=1.4)

table(chem$Haul_id)
sum(as.vector(table(chem$Haul_id)))



```


#Read in environmental data layers
```{r}

#temp
temp.r1.14<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/temp1_14.grd')
temp.r4.14<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/temp4_14.grd')
temp.r1.15<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/temp1_15.grd')

plot(temp.r1.14)
plot(temp.r4.14)
plot(temp.r1.15)


#sal
sal.r1.14<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/sal1_14.grd')
sal.r4.14<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/sal4_14.grd')
sal.r1.15<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/sal1_15.grd')

plot(sal.r1.14)
plot(sal.r4.14)
plot(sal.r1.15)

#sed
sed.r<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/sed.grd')
as.factor(sed.r)
plot(sed.r)

#
chl.r1.14<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/chl1_14.grd')
chl.r4.14<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/chl4_14.grd')
chl.r1.15<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/chl1_15.grd')

plot(chl.r1.14)
plot(chl.r4.14)
plot(chl.r1.15)

#dist
alldist.r<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/alldist.grd')

plot(alldist.r)

#aspect
aspect.r<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/aspect.grd')

plot(aspect.r)

#bath
bath.r<- raster('F:/R_script/Microchemistry/Elemental_maps/Env_layers/bath.grd')

plot(bath.r)



```




# Rasteize elemental data
```{r}
###produce raster from data points for element sampling locations
r<- raster(bath.r)
names(chem.spdfT)
# need to have a raster with an ID variable
haulID<- rasterize(chem.spdfT, r,field = 'Haul_id')

# 
# summary(Na.m)
# summary(chem$Na)
# Mg.m<- rasterize(chem.spdfT, r,field = 'Mg' ,fun= mean)
# Ba.m<- rasterize(chem.spdfT, r,field = 'BaCor' ,fun= mean)
# Sr.m<- rasterize(chem.spdfT, r,field = 'Sr' ,fun= mean)
# Mn.m<- rasterize(chem.spdfT, r,field = 'MnCor' ,fun= mean)
# Cu.m<- rasterize(chem.spdfT, r,field = 'CuT' ,fun= mean)
# Rb.m<- rasterize(chem.spdfT, r,field = 'Rb' ,fun= mean)
# Li.m<- rasterize(chem.spdfT, r,field = 'Li' ,fun= mean)
# Sc.m<- rasterize(chem.spdfT, r,field = 'Sc' ,fun= mean)
# 
# Na.er<- rasterize(chem.spdfT, r,field = 'Na' ,fun= sd)
# Mg.er<- rasterize(chem.spdfT, r,field = 'Mg' ,fun= sd)
# Ba.er<- rasterize(chem.spdfT, r,field = 'BaCor' ,fun= sd)
# Sr.er<- rasterize(chem.spdfT, r,field = 'Sr' ,fun= sd)
# Mn.er<- rasterize(chem.spdfT, r,field = 'MnCor' ,fun= sd)
# Cu.er<- rasterize(chem.spdfT, r,field = 'CuT' ,fun= sd)
# Rb.er<- rasterize(chem.spdfT, r,field = 'Rb' ,fun= sd)
# Li.er<- rasterize(chem.spdfT, r,field = 'Li' ,fun= sd)
# Sc.er<- rasterize(chem.spdfT, r,field = 'Sc' ,fun= sd)

```

# Trim all layers to same extent
```{r Trim data layers to fit extent and sediment }

#### trim data layers to fit sed.r - if sed gets dropped from the model come back here 
plot(bath.r)
fun<- function(x) {ifelse(x>0, NA, x)}
bath.r<- calc(bath.r, fun= fun)

####### maybe trim depth down to be more in line with the actual data max depth from mature
fun1.1<- function(z) {ifelse(z >= -230, z, NA)}
bath.r<- calc(bath.r, fun =fun1.1)
#cut1<- bath.r/bath.r - dont need this anymore as I condensed the cuts into "cut3"
plot(bath.r, col='black')
plot(landT, col='grey30', add=T)
# plot(bath.r)
# clip.test<- drawExtent() # use this to get the extent below

clip.ext<- extent(c(-535000, -291713.7,  7495397,  8473010)) # extent to crop out can always move these


clip<- crop(bath.r, clip.ext)# this makes a raster to chop with

clip<- extend(clip, bath.r)# this makes the cooky cutter big in line with the origional
plot(clip)# lets see it
bath.r <- mask(bath.r, clip, inverse=TRUE) # chop out the top corner and the forth
plot(bath.r)





# short routine to swap rock(4) to 5 so it makes it easier to get rid of later - prob dont want to do this
funA<- function(a){ifelse(a=='5',10, a)}
sed.r<- calc(sed.r, fun=funA)
funB<- function(b){ifelse(b=='4',5, b)}
sed.r<- calc(sed.r, fun=funB)
funC<- function(c){ifelse(c=='10',4, c)}
sed.r<- calc(sed.r, fun=funC)
#cut2<- sed.r/sed.r

# 
fun2<- function(y){ifelse(y=='5',NA, y)}
sed.r<- calc(sed.r, fun=fun2)


## dont use sediment so go back and smooth off the sedimant chunk
#locator(n=1)
polygon1<-  readWKT("POLYGON((-808916.7 7254798,  -1112122 7804945,  -1157574  6790310, -897355.8 6790310,-808916.7 7254798))")
sp::proj4string(polygon1) <- mrc
plot(polygon1, add=T)


cut1<- bath.r/bath.r


cut2 <- mask(cut1, polygon1, inverse=TRUE)
plot(cut2)



bath.r<- bath.r*cut2
plot(bath.r)
plot(cut2)


bath.r<- bath.r*cut2
aspect.r<- aspect.r*cut2

temp.r1.14<- temp.r1.14*cut2
#temp.r4.14<- temp.r4.14*cut3
#temp.r1.15<- temp.r1.15*cut3



sal.r1.14<- sal.r1.14*cut2
#sal.r4.14<- sal.r4.14*cut3
#sal.r1.15<- sal.r1.15*cut3



chl.r1.14<- chl.r1.14*cut2
#chl.r4.14<- chl.r4.14*cut3
#chl.r1.15<- chl.r1.15*cut3


alldist.r<-alldist.r*cut2


# #elements
# trim.Na.m<- cut3 * Na.m
# trim.Mg.m<- cut3 * Mg.m
# trim.Ba.m<- cut3 * Ba.m
# trim.Sr.m<- cut3 * Sr.m
# trim.Mn.m<- cut3 * Mn.m
# trim.Cu.m<- cut3 * Cu.m
# trim.Rb.m<- cut3 * Rb.m
# trim.Li.m<- cut3 * Li.m
# trim.Sc.m<- cut3 * Sc.m
# 
# trim.Na.er<- cut3 * Na.er
# trim.Mg.er<- cut3 * Mg.er
# trim.Ba.er<- cut3 * Ba.er
# trim.Sr.er<- cut3 * Sr.er
# trim.Mn.er<- cut3 * Mn.er
# trim.Cu.er<- cut3 * Cu.er
# trim.Rb.er<- cut3 * Rb.er
# trim.Li.er<- cut3 * Li.er
# trim.Sc.er<- cut3 * Sc.er



#then need to do the same for tide - leave this out as does not cover all of IS
#tide.avail<- tide.r/tide.r
#trim.cpue14.r<- tide.avail * trim.cpue14.r
#trim.cpue15.r<- tide.avail * trim.cpue15.r




############################# sample from rasters at the relevent sampling points #########################
##using 'trim.cpue.r' to include sedement
ST<- (haulID)/(haulID) ### produce a raster of 1s from the Na raster for each year at sampling 
plot(cut2)
plot(ST, col='Black', add=T)
STdepth<- bath.r * ST### make a raster of the depth data at that sampling point(depth station)

STdist<- alldist.r *ST ## and distance to shore

STsed<- as.integer(sed.r * ST)###do the same for sedment (sedement samp)

STtemp<-temp.r1.14 * ST### do the same for the temperature layer
#STtemp10<-temp10 * ST10 might need to do this several times to make layers for different years if im including lots more than one year

STsal<-sal.r1.14 * ST

STchl<-chl.r1.14 * ST

STasp<- aspect.r * ST

##### remake the 'training' data frame
haulID.spdf<- rasterToPoints(haulID, spatial =T)
id<- as.data.frame(haulID.spdf)

STdepth.spdf<- rasterToPoints(STdepth, spatial=T) ### make depth at sample points into a spdf and add haulID so we can combine it with the data
env<- as.data.frame(STdepth.spdf)
env<- cbind(env, 'Haul_id'=id[,1])
colnames(env)[1:3]<- c('depth', 'x', 'y')

STdist.spdf<- rasterToPoints(STdist, spatial=T) ## and dist
dist<- as.data.frame(STdist.spdf)
env<- cbind(env, 'dist'=dist[,1])


STasp.spdf<- rasterToPoints(STasp, spatial=T) ## and dist
asp<- as.data.frame(STasp.spdf)
env<- cbind(env, 'asp'=asp[,1])


#STsed.spdf<- rasterToPoints(STsed,spatial =T)### and again for sedement  # not using this as too may samples on
#sed<- as.data.frame(STsed.spdf)
#env<- cbind(env, 'sed'=as.factor(sed[,1]))


STtemp.spdf<-rasterToPoints(STtemp,spatial=T) ### and temp
temp<- as.data.frame(STtemp.spdf)
env<- cbind(env, 'temp'=temp[,1])


STsal.spdf<-rasterToPoints(STsal,spatial=T) ### and salinity
sal<- as.data.frame(STsal.spdf)
env<- cbind(env, 'sal'=sal[,1])

STchl.spdf<-rasterToPoints(STchl,spatial=T) ### and salinity
chl<- as.data.frame(STchl.spdf)
env<- cbind(env, 'chl'=chl[,1])


##combine to one spdf and accounting for multiple measures in the origional data frame
datr<- merge(env, chem, by= 'Haul_id')

head(datr)


 

```



## further reduced area for step4 predictions
```{r}
# 
# bath.r<- bath.r*cut2
# cut3<- bath.r/bath.r
# plot(cut3)
# plot(haulID, add=T, col='black')
# 
# 
# 
# ####second clip
# clip2.ext<- extent(c(-1500000, -995000,  7400000,  8473010)) # extent to crop out can always move these
# 
# 
# clip2<- crop(cut3, clip2.ext)# this makes a raster to chop with
# 
# clip2<- extend(clip2, bath.r)# this makes the cooky cutter big in line with the origional
# plot(clip2)# lets see it
# cut3 <- mask(cut3, clip2, inverse=TRUE) 
# 
# plot(cut3)
# plot(haulID, add=T, col='black')
# 
# clip3.ext<- extent(c(-1500000, -400000,  8150000,  8473010)) # extent to crop out can always move these
# 
# 
# clip3<- crop(cut3, clip3.ext)# this makes a raster to chop with
# 
# clip3<- extend(clip3, bath.r)# this makes the cooky cutter big in line with the origional
# plot(clip3)# lets see it
# cut3 <- mask(cut3, clip3, inverse=TRUE) # chop out the top corner and the forth
# 
# plot(cut3)
# plot(haulID, add=T, col='black')
# 
# 
# 
# 
# polygon1<-  readWKT("POLYGON((-807010.4 7438129, -1023592 7808483, -1010597 7379652,-817839.5 7314677,-807010.4 7438129))")
# sp::proj4string(polygon1) <- mrc
# plot(polygon1, add=T)
# 
# 
# 
# cut3 <- mask(cut3, polygon1, inverse=TRUE)
# plot(cut3)
# ## and then again in north
# 
# #locator(n=1)
# polygon2<-  readWKT("POLYGON((-766456.9 8165917, -1005046 7925623, -1005046 8165917, -766456.9 8165917))")
# sp::proj4string(polygon2) <- mrc
# plot(polygon2, add=T)
# 
# 
# 
# cut3 <- mask(cut3, polygon2, inverse=TRUE)
# plot(cut3)
# 
# plot(haulID, add=T, col='black')
# 
# ### then chop off the bottom
# #locator(n=1)
# clip4.ext<- extent(c(-1200000, -400000,  6785628,  7000000)) # extent to crop out can always move these
# 
# 
# clip4<- crop(cut3, clip4.ext)# this makes a raster to chop with
# 
# clip4<- extend(clip4, bath.r)# this makes the cooky cutter big in line with the origional
# plot(clip4)# lets see it
# cut3 <- mask(cut3, clip4, inverse=TRUE) # chop out the top corner and the forth
# 
# plot(cut3)
# plot(haulID, add=T, col='black')
# 
# 
# 
# 
# 
# 
# bath.r<- bath.r*cut3
# 
# aspect.r<- aspect.r*cut3
# 
# temp.r1.14<- temp.r1.14*cut3
# temp.r4.14<- temp.r4.14*cut3
# temp.r1.15<- temp.r1.15*cut3
# 
# 
# 
# sal.r1.14<- sal.r1.14*cut3
# sal.r4.14<- sal.r4.14*cut3
# sal.r1.15<- sal.r1.15*cut3
# 
# 
# 
# chl.r1.14<- chl.r1.14*cut3
# chl.r4.14<- chl.r4.14*cut3
# chl.r1.15<- chl.r1.15*cut3
# 
# 
# alldist.r<-alldist.r*cut3
# 
# 
# # #elements
# # trim.Na.m<- cut3 * Na.m
# # trim.Mg.m<- cut3 * Mg.m
# # trim.Ba.m<- cut3 * Ba.m
# # trim.Sr.m<- cut3 * Sr.m
# # trim.Mn.m<- cut3 * Mn.m
# # trim.Cu.m<- cut3 * Cu.m
# # trim.Rb.m<- cut3 * Rb.m
# # trim.Li.m<- cut3 * Li.m
# # trim.Sc.m<- cut3 * Sc.m
# # 
# # trim.Na.er<- cut3 * Na.er
# # trim.Mg.er<- cut3 * Mg.er
# # trim.Ba.er<- cut3 * Ba.er
# # trim.Sr.er<- cut3 * Sr.er
# # trim.Mn.er<- cut3 * Mn.er
# # trim.Cu.er<- cut3 * Cu.er
# # trim.Rb.er<- cut3 * Rb.er
# # trim.Li.er<- cut3 * Li.er
# # trim.Sc.er<- cut3 * Sc.er
# 
# 
# 
# #then need to do the same for tide - leave this out as does not cover all of IS
# #tide.avail<- tide.r/tide.r
# #trim.cpue14.r<- tide.avail * trim.cpue14.r
# #trim.cpue15.r<- tide.avail * trim.cpue15.r
# 
# 
# 
# 
# ############################# sample from rasters at the relevent sampling points #########################
# ##using 'trim.cpue.r' to include sedement
# ST<- (haulID)/(haulID) ### produce a raster of 1s from the Na raster for each year at sampling 
# plot(cut3)
# plot(ST, col='Black', add=T)
# STdepth<- bath.r * ST### make a raster of the depth data at that sampling point(depth station)
# 
# STdist<- alldist.r *ST ## and distance to shore
# 
# STsed<- as.integer(sed.r * ST)###do the same for sedment (sedement samp)
# 
# STtemp<-temp.r4.14 * ST### do the same for the temperature layer
# #STtemp10<-temp10 * ST10 might need to do this several times to make layers for different years if im including lots more than one year
# 
# STsal<-sal.r4.14 * ST
# 
# STchl<-chl.r4.14 * ST
# 
# STasp<- aspect.r * ST
# 
# ##### remake the 'training' data frame
# haulID.spdf<- rasterToPoints(haulID, spatial =T)
# id<- as.data.frame(haulID.spdf)
# 
# STdepth.spdf<- rasterToPoints(STdepth, spatial=T) ### make depth at sample points into a spdf and add haulID so we can combine it with the data
# env<- as.data.frame(STdepth.spdf)
# env<- cbind(env, 'Haul_id'=id[,1])
# colnames(env)[1:3]<- c('depth', 'x', 'y')
# 
# STdist.spdf<- rasterToPoints(STdist, spatial=T) ## and dist
# dist<- as.data.frame(STdist.spdf)
# env<- cbind(env, 'dist'=dist[,1])
# 
# 
# STasp.spdf<- rasterToPoints(STasp, spatial=T) ## and dist
# asp<- as.data.frame(STasp.spdf)
# env<- cbind(env, 'asp'=asp[,1])
# 
# 
# STsed.spdf<- rasterToPoints(STsed,spatial =T)### and again for sedement
# sed<- as.data.frame(STsed.spdf)
# env<- cbind(env, 'sed'=as.factor(sed[,1]))
# 
# 
# STtemp.spdf<-rasterToPoints(STtemp,spatial=T) ### and temp
# temp<- as.data.frame(STtemp.spdf)
# env<- cbind(env, 'temp'=temp[,1])
# 
# 
# STsal.spdf<-rasterToPoints(STsal,spatial=T) ### and salinity
# sal<- as.data.frame(STsal.spdf)
# env<- cbind(env, 'sal'=sal[,1])
# 
# STchl.spdf<-rasterToPoints(STchl,spatial=T) ### and salinity
# chl<- as.data.frame(STchl.spdf)
# env<- cbind(env, 'chl'=chl[,1])
# 
# 
# ##combine to one spdf and accounting for multiple measures in the origional data frame
# datr<- merge(env, chem, by= 'Haul_id')
# 
# head(datr)
# 
# writeRaster(cut3, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/all_area_cut', format = 'raster', overwrite=T)
# 


```




```{r produce data for model}


#write.csv(dat, 'F:/R_script/SDM/full_area_time/full_mat_data.csv')
#write.csv(dat, '/Volumes/PHD/R_script/SDM/full_area_time/full_mat_data.csv')

#write.csv(dat0, 'F:/R_script/SDM/full_area_time/full_zero_data.csv')
#write.csv(dat0, '/Volumes/PHD/R_script/SDM/full_area_time/full_zero_data.csv')

#write.csv(dat1, 'F:/R_script/SDM/full_area_time/full_Age1_data.csv')
#write.csv(dat1, '/Volumes/PHD/R_script/SDM/full_area_time/full_Age1_data.csv')


```


#make prediction data
```{r Generate prediction data}
# generate 'newdata' for the predictions
head(dat)


depth.v<- as.data.frame(bath.r, xy=T)

dist.v<- as.vector(alldist.r) 
plot(bath.r)
plot(alldist.r)
plot(sed.r)
plot(temp.r4.14)
plot(sal.r4.14)
plot(chl.r4.14)
plot(aspect.r)


sed.v<- as.vector(sed.r)
# need to remove levels 1 and 5 from here as there are no samples on these areas
sed.v[sed.v == 1 ] <- NA

temp.v<-as.vector(temp.r4.14) 

sal.v<-as.vector(sal.r4.14)

chl.v<- as.vector(chl.r4.14)

asp.v<- as.vector(aspect.r)

newdat<- cbind(depth.v, 'dist'=dist.v, 'sed'=as.factor(sed.v), 'temp'=temp.v, 'sal'=sal.v, 'chl'=chl.v, 'asp'= asp.v)
colnames(newdat)[1:3]<- c('x', 'y', 'depth')

head(newdat)


# ## add the gear type - may need a loop to add stuff later
# 
# gear<- vector(mode='integer',length=nrow(new_0_dat))
# 
# for(i in 1: nrow(new_0_dat)){
# gear[i]<- if( new_0_dat$LongT[i] > -860000 & new_0_dat$LatT[i]< 7365000) 3 else 2
# }
# 
# 
# new_0_dat<- cbind(new_0_dat, gear)
# head(new_0_dat)
# summary(new_0_dat$gear)


### try removing all nas (to resolve tide problem)
# new_mat_dat<- na.omit(new_mat_dat)
# new_0_dat<- na.omit(new_0_dat)
# write.csv(new_mat_dat, file = 'F:/R_script/SDM/full_area_time/layers_output/new_Mature_dat.csv')
# write.csv(new_mat_dat, file = '/Volumes/PHD/R_script/SDM/full_area_time/layers_output/new_Mature_dat.csv')

#write.csv(new_0_dat, file = 'F:/R_script/SDM/full_area_time/layers_output/new_0_dat.csv')
#write.csv(new_0_dat, file = '/Volumes/PHD/R_script/SDM/full_area_time/layers_output/new_0_dat.csv')

```


#sample site plots
```{r}

full.ext<- extent(c(-10, -1, 52, 60))


sea.spdf<- readOGR(dsn="F:/R_script/basic_maps", layer="basic_sea")
depth.sldf<- readOGR(dsn="F:/R_script/basic_maps", layer="depth_area")

land.tmp<- readOGR(dsn="F:/R_script/basic_maps", layer="Britain_Proj_Dist")
land.tmp <- spTransform(land.tmp, CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")) ### re project land
land.spdf <- crop(land.tmp, full.ext) ## crop land down to the correct extent
sea.spdf <- crop(sea.spdf, full.ext) ## crop land down to the correct extent


#### initially produce a map of everywhere and all time points
## bind coords into sigle object
coords.tmp<- cbind(chem$long, chem$lat)
## create spdf object
samples.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(chem),
                                  proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))


#### subset depth for 200m line
twohun.sldf <- subset(depth.sldf, depth.sldf$ELEVATION == 200)
onehun.sldf<- subset(depth.sldf, depth.sldf$ELEVATION == 100)


par(mar = c(4,5,2,2))
#par(mar = c(4,5,4,2))   #7265958


### plot land and sea####

plot(land.spdf, add = F, col = 'cornsilk', border = 'cornsilk')
plot(sea.spdf, add=T, col = 'cornflower blue')
## axes - note this needs changed on mac for degree symbol
axis(1, at = c(-1:-10), label=F, pos = 52, tck = -0.015)
axis(1, at = c(-1,-3,-5,-7,-9),labels = parse(text = paste(c(1,3,5,7,9), "*degree~W", sep = "")),tick = F, cex.axis = 2, pos = 52, padj=0.2)
axis(2, at = seq(52,60, by= 0.5), label = F,pos = -10, tck = -0.015)

axis(2, at = c(52:60), labels = parse(text = paste(c(52:60), "*degree ~ N", sep = "")),tick = F, pos = -10, las = 1, cex.axis=2, hadj=1)
axis(3, labels = F, at = c(-1:-10), lwd.ticks=0, pos=60)
axis(4, labels = F, pos = -1, at = seq(52,60, by= 0.5), lwd.ticks=0)

## bathemetry
plot(onehun.sldf,add=T, col = ' lightskyblue3')
plot(twohun.sldf,add =T, col = 'lightskyblue4')
rect(-9.8, 55.7, -8.8, 56.3, col = 'cornflowerblue', border = NA )
rect(-9.6, 54.4, -8.8, 55.08, col = 'cornflowerblue', border = NA)
text(-9.2,56, labels= '200m', col ='lightskyblue4', cex = 0.8, srt = 81)
text(-9.35,54.8, labels= '100m', col ='lightskyblue3', cex = 0.8, srt = 65)

## country names
text(-3.6, 57, labels = 'Scotland', srt=40)
text(-1.8, 54, labels = 'England', srt=50)
text(-6.5, 54.7, labels = 'N. Ireland', srt=-54)
text(-7.5, 53, labels = 'Eire')
text(-3.4, 53, labels = 'Wales')


#str(chem$region)
### add sampling points
plot(samples.spdf, add =T, cex = 2.5, pch= 1, lwd=4)
#text(samples.spdf, cex = 2.5, labels=chem$HaulF)
#legend(-2.75, 53.1,legend =levels(chem$region),
 #      pch= c(15,17,19,2,1), cex = 1, box.col = 'black', bg = 'cornsilk', horiz = F)



north.arrow(xb=-9.5, yb=59.5, len=0.08, lab="N")



```



# bounding box, knots and extra area variables
```{r}
### modeling data is in datr
names(datr)
str(datr)
summary(datr$Na)

region<-as.factor(datr$Haul_id)
levels(region) <- c("Cl",  
                    "Inshore", 
                    "Inshore",
                    "Inshore", 
                    "EIS",
                    "WIS", "Cl")
datr<-cbind(datr, region)

### set up the boundary for film

plot(bath.r) # here is the bath.r boundary
bath.spdf<- rasterToPolygons(bath.r, dissolve=TRUE) # turn this into polygons - might wantr to do this earlier if i need higher resolution
plot(bath.spdf)
outline<- gUnaryUnion(bath.spdf,id=NULL) #get ouitline of bath.spdf
plot(outline)

outline.coords<- fortify(outline) # use fortify from ggplot to get the coords
plot(outline.coords$long, outline.coords$lat)
points(outline.coords[1,1], outline.coords[1,2], col='blue', pch=19) # here is the first point
points(outline.coords[2,1], outline.coords[2,2], col='pink', pch=19) # and 2

points(outline.coords[nrow(outline.coords),1], outline.coords[nrow(outline.coords),2], col='red', pch=19) # last point is one of the other loops

points(outline.coords[1:861,1], outline.coords[1:861,2], col='green', pch=19) # this is the 'last' point in the main loop
points(outline.coords[862,1], outline.coords[862,2], col='black', pch=19) # this one is another loop, 'skye'

outline.coords<- outline.coords[1:861,1:2]
head(outline.coords)

# extractCoords <- function(sp.df) # function to extract the coords from the spdf object
# {
#     results <- list()
#     for(i in 1:length(sp.df@polygons[[1]]@Polygons))
#     {
#         results[[i]] <- sp.df@polygons[[1]]@Polygons[[i]]@coords
#     }
#     results <- Reduce(rbind, results)
#     results
# } # this works but not in the ordered from I think I need


bound <- list(list(x =outline.coords[,1], y = outline.coords[,2]))#, f = rep(0, nrow(outline.coords))))

str(bound[[1]]$x)

#sort out bound first
soap_check(bound)



### now choose the location of knots - try just the center point of each cell in bath


space= 5.5 ### increase this to increase spacing between knots
knots<- rasterToPoints(aggregate(bath.r, fact=space), spatial=TRUE)
names(knots)
str(knots)
head(knots)


plot(knots, cex=0.5, pch=19)
points(outline.coords, col='red', pch=1, cex=0.8)
#plot(bath.r, add=T)
## use gIntersection to remove knots right on the edge
buff.outline<- gBuffer(outline, width=-8000)

plot(outline)
plot(buff.outline, add=T, col='red')

knots<- gIntersection(knots, buff.outline)
knots<- coordinates(knots)

plot(knots, cex=0.5, pch=19)
points(outline.coords, col='red', pch=1, cex=0.8)

knots<- as.data.frame(knots)
#knots <- knots[with(knots, inSide(bound, x, y)), ]

plot(knots, cex=0.5, pch=19)
points(outline.coords, col='red', pch=1, cex=0.8)

soap_check(bound, knots)


L <- parse(text = paste(c(10:3), "*degree ~W", sep = "")) # longitudes
LN<- parse(text = paste(c(52:59), "*degree ~N", sep = "")) #lats

par(mar = c(5,6,4,2))
plot(outline.coords, col='white', pch=19, cex=0.8, xlab=NA, ylab=NA,xaxt='n', yaxt='n', bty='n')
axis(1, at=c(-1066000,-961285.8,-856571.5,-751857.2,-647142.9,-542428.6,-437714.3,-333000), L, lwd.ticks=1, cex.axis=2, padj=0.8, pos=6800000)
axis(2, at=c(6800000,7029142.9,7258285.8,7487428.7,7716571.6,7945714.5,8174857.4,8404000), labels=LN, lwd.ticks=1, pos=-1089000, las=1,cex.axis=2)
axis(4, at=c(6800000,8404000), labels=NA, lwd.ticks=0, pos=-333000)
axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
plot(landT, add=T,col= 'bisque')
points(outline.coords, col='red', pch=19, cex=2)
points(knots, cex=2, pch=19)


```


#look for meaningful relationships and any corelation in environmental data
```{r}
names(datr)
#environment variables
depth.rel<- tapply(datr$depth, INDEX= as.factor(datr$Haul_id), FUN='max', simplify=TRUE)
x.rel<- tapply(datr$x, INDEX= as.factor(datr$Haul_id), FUN='max', simplify=TRUE)
y.rel<- tapply(datr$y, INDEX= as.factor(datr$Haul_id), FUN='max', simplify=TRUE)
temp.rel<- tapply(datr$temp, INDEX= as.factor(datr$Haul_id), FUN='max', simplify=TRUE)
sal.rel<- tapply(datr$sal, INDEX= as.factor(datr$Haul_id), FUN='max', simplify=TRUE)
chl.rel<- tapply(datr$chl, INDEX= as.factor(datr$Haul_id), FUN='max', simplify=TRUE)



#Na
Na.mean<- tapply(datr$Na, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
Na.se<- (sqrt(tapply(datr$Na, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- Na.mean
se<- Na.se

plot(depth.rel, mean, pch=19, cex=3, ylim=c(2250,4250))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$depth, datr$Na, col='cadetblue', pch=19)

line<- gam(Na~s(depth, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)

plot(x.rel, mean, pch=19, cex=3, ylim=c(2250,4250))
arrows(x.rel, (mean-se), x.rel, (Na.mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$Na, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3, ylim=c(2250,4250))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$Na, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3, ylim=c(2250,4250))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$Na, col='cadetblue', pch=19)

line<- gam(Na~s(temp, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)

plot(sal.rel, mean, pch=19, cex=3, ylim=c(2250,4250))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$Na, col='cadetblue', pch=19)

line<- gam(Na~s(sal, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)


#Sr
Sr.mean<- tapply(datr$Sr, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
Sr.se<- (sqrt(tapply(datr$Sr, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- Sr.mean
se<- Sr.se

plot(depth.rel, mean, pch=19, cex=3, ylim=c(500,3000))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$depth, datr$Sr, col='cadetblue', pch=19)

line<- gam(Sr~s(depth, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)

plot(x.rel, mean, pch=19, cex=3, ylim=c(500,3000))
arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$Sr, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3, ylim=c(500,3000))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$Sr, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3, ylim=c(500,3000))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$Sr, col='cadetblue', pch=19)

line<- gam(Sr~s(temp, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)

plot(sal.rel, mean, pch=19, cex=3, ylim=c(500,3000))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$Sr, col='cadetblue', pch=19)

line<- gam(Sr~s(sal, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)




#Mn
Mn.mean<- tapply(datr$Mn, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
Mn.se<- (sqrt(tapply(datr$Mn, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- Mn.mean
se<- Mn.se
 
plot(depth.rel, mean, pch=19, cex=3, ylim=c(0,5))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$depth, datr$Mn, col='cadetblue', pch=19)

line<- gam(Mn~s(depth, k=4), data=datr, family=Gamma)
summary(line)
plot(line, residuals=T, cex=4)

plot(x.rel, mean, pch=19, cex=3, ylim=c(0,1.5))
arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$Mn, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3, ylim=c(0,1.5))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$Mn, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3, ylim=c(0,1.5))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$Mn, col='cadetblue', pch=19)

line<- gam(Mn~s(temp, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

plot(sal.rel, mean, pch=19, cex=3, ylim=c(0,1.5))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$Mn, col='cadetblue', pch=19)

line<- gam(Mn~s(sal, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


#Rb
Rb.mean<- tapply(datr$Rb, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
Rb.se<- (sqrt(tapply(datr$Rb, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- Rb.mean
se<- Rb.se
 
plot(depth.rel, mean, pch=19, cex=3, ylim=c(0,0.2))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3)
points(datr$depth, datr$Rb, col='cadetblue', pch=19)

line<- gam(Rb~s(depth, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

plot(x.rel, mean, pch=19, cex=3, ylim=c(0,0.2))
arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$Rb, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3, ylim=c(0,0.2))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$Rb, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3, ylim=c(0,0.2))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$Rb, col='cadetblue', pch=19)

line<- gam(Rb~s(temp, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

plot(sal.rel, mean, pch=19, cex=3, ylim=c(0,0.2))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$Rb, col='cadetblue', pch=19)

line<- gam(Rb~s(sal, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


#Li
# Li.mean<- tapply(datr$Li, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
# Li.se<- (sqrt(tapply(datr$Li, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2
# 
# mean<- Li.mean
# se<- Li.se
#  
# plot(depth.rel, mean, pch=19, cex=3, ylim=c(0,3))
# arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3)
# points(datr$depth, datr$Li, col='cadetblue', pch=19)
# 
# line<- gam(Li~s(depth, k=4), data=datr)
# summary(line)
# plot(line, residuals=T, cex=4)
# 
# plot(x.rel, mean, pch=19, cex=3, ylim=c(0,3))
# arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
# points(datr$x, datr$Li, col='cadetblue', pch=19)
# 
# plot(y.rel, mean, pch=19, cex=3,ylim=c(0,3))
# arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
# points(datr$y, datr$Li, col='cadetblue', pch=19)
# 
# plot(temp.rel, mean, pch=19, cex=3, ylim=c(0,3))
# arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
# points(datr$temp, datr$Li, col='cadetblue', pch=19)
# 
# line<- gam(Li~s(depth, k=4), data=datr)
# summary(line)
# plot(line, residuals=T, cex=4)
# 
# plot(sal.rel, mean, pch=19, cex=3, ylim=c(0,3))
# arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
# points(datr$sal, datr$Li, col='cadetblue', pch=19)
# 
# line<- gam(Li~s(depth, k=4), data=datr)
# summary(line)
# plot(line, residuals=T, cex=4)


#Sc
Sc.mean<- tapply(datr$Sc, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
Sc.se<- (sqrt(tapply(datr$Sc, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- Sc.mean
se<- Sc.se
 
plot(depth.rel, mean, pch=19, cex=3, ylim=c(1,1.1))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3)
points(datr$depth, datr$Sc, col='cadetblue', pch=19)

line<- gam(Sc~s(depth, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

plot(x.rel, mean, pch=19, cex=3, ylim=c(1,1.1))
arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$Sc, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3,ylim=c(1,1.1))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$Sc, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3, ylim=c(1,1.1))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$Sc, col='cadetblue', pch=19)

line<- gam(Sc~s(temp, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

plot(sal.rel, mean, pch=19, cex=3, ylim=c(1,1.1))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$Sc, col='cadetblue', pch=19)

line<- gam(Sc~s(sal, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

#additional

#Ba
Ba.mean<- tapply(datr$Ba, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
Ba.se<- (sqrt(tapply(datr$Ba, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- Ba.mean
se<- Ba.se
 
plot(depth.rel, mean, pch=19, cex=3, ylim=c(0,2))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3)
points(datr$depth, datr$Ba, col='cadetblue', pch=19)

line<- gam(Ba~s(depth, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)

plot(x.rel, mean, pch=19, cex=3,  ylim=c(0,2))
arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$Ba, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3,  ylim=c(0,2))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$Ba, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3,  ylim=c(0,2))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$Ba, col='cadetblue', pch=19)

line<- gam(Ba~s(temp, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)


plot(sal.rel, mean, pch=19, cex=3,  ylim=c(0,2))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$Ba, col='cadetblue', pch=19)

line<- gam(Ba~s(sal, k=4), data=datr, family='Gamma')
summary(line)
plot(line, residuals=T, cex=4)



#P
P.mean<- tapply(datr$P, INDEX= as.factor(datr$Haul_id), FUN='mean', simplify=TRUE)
P.se<- (sqrt(tapply(datr$P, INDEX= as.factor(datr$Haul_id), FUN='var', simplify=TRUE)/sqrt(20)))*2

mean<- P.mean
se<- P.se
 
plot(depth.rel, mean, pch=19, cex=3, ylim=c(100,700))
arrows(depth.rel, (mean-se), depth.rel, (mean+se), length=0.25, angle=90, code=3)
points(datr$depth, datr$P, col='cadetblue', pch=19)

line<- gam(P~s(depth, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)


plot(x.rel, mean, pch=19, cex=3,  ylim=c(100,700))
arrows(x.rel, (mean-se), x.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$x, datr$P, col='cadetblue', pch=19)

plot(y.rel, mean, pch=19, cex=3, ylim=c(100,700))
arrows(y.rel, (mean-se), y.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$y, datr$P, col='cadetblue', pch=19)

plot(temp.rel, mean, pch=19, cex=3,  ylim=c(100,700))
arrows(temp.rel, (mean-se), temp.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$temp, datr$P, col='cadetblue', pch=19)

line<- gam(P~s(temp, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)


plot(sal.rel, mean, pch=19, cex=3, ylim=c(100,700))
arrows(sal.rel, (mean-se), sal.rel, (mean+se), length=0.25, angle=90, code=3 )
points(datr$sal, datr$P, col='cadetblue', pch=19)

line<- gam(P~s(sal, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)


# Mg

line<- gam(Mg~s(depth, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)


line<- gam(Mg~s(temp, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)

line<- gam(Mg~s(sal, k=4), data=datr)
summary(line)
plot(line, residuals=T, cex=4)



names(datr)
#corvif(datr[,c(3,4, 8)])### drop long
pairs(datr[,c(2,7, 8)],lower.panel = panel.smooth2, upper.panel =  panel.cor, diag.panel=panel.hist)
plot(temp.rel, sal.rel)
plot(temp.rel, depth.rel)
plot(depth.rel, sal.rel)
plot(sal.rel, x.rel)
plot(sal.rel, y.rel)

```


#gam fitting
```{r}

## try elements independently first - also can try mvabund for multivariate and a unified one for all time points with year included as a variable
names(datr)
summary(datr$Na)


Na1<-gam(Na~   s(x, y, bs='so', xt =list(bnd=bound)),
         data = datr, family = gaussian, knots=knots)

 # Na2<-gam(Na~   s(x, y, bs='so', xt =list(bnd=bound)) + s(sal, bs='cr', k =6),
 #         data = datr, family = gaussian, knots=knots)
 # AIC(Na1, Na2)


summary(Na1)
gam.check(Na1)
plot(Na1)


names(datr)
summary(datr$Mg)

 Mg1<- gam(Mg~   s(x, y, bs='so', xt =list(bnd=bound)),
           data = datr, family = gaussian, knots=knots)

 
 # Mg2<- gam(Mg~   s(x, y, bs='so', xt =list(bnd=bound))+ s(sal, bs='cr', k =6),
 #           data = datr, family = gaussian, knots=knots)
 # 
 # AIC(Mg1, Mg2)

summary(Mg1)
gam.check(Mg1)
plot(Mg1, main='Mg')
plot(landT, add=T, col ='cornsilk')

names(datr)
summary(datr$P)

 P1<- gam(P~   s(x, y, bs='so', xt =list(bnd=bound)),
           data = datr, family = gaussian, knots=knots)


summary(P1)
gam.check(P1)
plot(P1, main='P')
plot(landT, add=T, col ='cornsilk')

names(datr)
summary(datr$Ba)

   Ba1<-gam(Ba~   s(x, y, bs='so', xt =list(bnd=bound)),
            data = datr,  family=Gamma, knots=knots)
      # 
      # Ba2<-gam(Ba~    s(temp, bs='cr', k =6),
      #        data = datr,  family=Gamma, knots=knots)
      # 
      # AIC(Ba1,Ba2) 
     
summary(Ba1)
gam.check(Ba1)
plot(Ba1)




names(datr)
summary(datr$Sr)



Sr1<- gam(Sr~   s(x, y, bs='so', xt =list(bnd=bound)),
          data = datr, family = gaussian, knots=knots)
# 
 # Sr2<- gam(Sr~  s(x, y, bs='so', xt =list(bnd=bound))+ s(depth, bs='cr', k =6),
 #           data = datr, family = gaussian, knots=knots)
 # AIC(Sr1,Sr2)

summary(Sr1)

corvif(datr[,c(2,5)])

gam.check(Sr1)
plot(Sr1)

#Mn
names(datr)
summary(datr$Mn)




 
 
 Mn1<-gam(Mn~  s(x, y, bs='so', xt =list(bnd=bound)),
         data = datr, family = Gamma, knots=knots)
 
#  Mn2<-gam(Mn~   s(x, y, bs='so', xt =list(bnd=bound))+ s(sal, bs='cr', k =6),
#          data = datr, family = Gamma, knots=knots)
#  
#  AIC(Mn1,Mn2)
# 
 summary(Mn1)
# 
# corvif(datr[,c(2,9)])

plot(Mn1, main ='Mn')
plot(landT, add=T, col ='cornsilk')

names(datr)
# summary(datr$Zn)
# 
# 
# 
# 
#  Zn1<-gam(Zn~   s(x, y, bs='so', xt =list(bnd=bound)),
#          data = datr, family = gaussian, knots=knots)
# 
# 
# summary(Zn1)
# 
# 
# 
# names(datr)
# summary(datr$CuT)
# 
#  
# 
#  #Cu1<-gam(CuT~   s(x, y, bs='so', xt =list(bnd=bound)) +s(dist, bs='cr', k=6),
#   #        data = datr, family = gaussian, knots=knots)
#    
#  Cu1<-gam(Cu~   s(x, y, bs='so', xt =list(bnd=bound)),
#           data = datr, family = gaussian, knots=knots)
# 
# 
# 
# 
# summary(Cu1)
# 
# corvif(datr[,c(2,5)])
# 
# gam.check(Cu1)
# plot(Cu1)


names(datr)
summary(datr$Rb)

   Rb1<-gam(Rb~   s(x, y, bs='so', xt =list(bnd=bound)) ,
             data = datr, family = Gamma, knots=knots)
#   


summary(Rb1)

corvif(datr[,c(2, 5,9)])

gam.check(Rb1)
plot(Rb1)



names(datr)
summary(datr$Li)


 

   Li1<-gam(Li~   s(x, y, bs='so', xt =list(bnd=bound)),
            data = datr, family = Gamma, knots=knots)
 

summary(Li1)

corvif(datr[,c(3, 4,10)])

gam.check(Li1)
plot(Li1)


names(datr)
summary(datr$Sc)


 
 
 #Sc1<-gam(Sc+1~   s(x, y, bs='so', xt =list(bnd=bound)),
         # data = datr, family = Gamma, knots=knots)
 
 Sc1<-gam(Sc~   s(x, y, bs='so', xt =list(bnd=bound))+ s(temp, bs='cr', k =6),
          data = datr, family = Gamma, knots=knots)

 #AIC(Sc1, Sc2)
summary(Sc2)


#corvif(datr[,c(2, 5,9)])

gam.check(Sc1)
plot(Sc2)


#### use for showing env effects
# pred.dat<- expand.grid('depth' = quantile(datr$depth)[2], 'temp'=seq(min(datr$temp),max(datr$temp)), 'long'= c(-600000))
# pred<- as.data.frame(predict(GMNa, se.fit=TRUE, newdata=pred.dat,  type="response", exclude= ti(gear)))
# head(pred)

```



#model predictions
```{r}


levels=1000
#Na
predNa<-as.data.frame(predict(Na1, se.fit=TRUE, newdata=newdat,  type="response"))
predNa<- cbind(predNa, newdat[,1:2])
head(predNa)

predNa<-na.omit(predNa)


coords.tmp<- cbind(predNa$x, predNa$y)
predNa.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predNa), proj4string = CRS(mrc))
pNa<- rasterize(predNa.spdf, bath.r , 'fit')
eNa<- rasterize(predNa.spdf, bath.r , 'se.fit')
image(pNa, main="predicted abundance",  col = topo.colors(levels));plot(landT, add=TRUE)

#Mg
predMg<-as.data.frame(predict(Mg1, se.fit=TRUE, newdata=newdat,  type="response"))
predMg<- cbind(predMg, newdat[,1:2])
head(predMg)
predMg<-na.omit(predMg)

summary(predMg$fit)

coords.tmp<- cbind(predMg$x, predMg$y)
predMg.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predMg), proj4string = CRS(mrc))
pMg<- rasterize(predMg.spdf, bath.r , 'fit')
eMg<- rasterize(predMg.spdf, bath.r , 'se.fit')
image(pMg, main="predicted abundance",  col = topo.colors(levels));plot(landT, add=TRUE)

# #P
# predP<-as.data.frame(predict(P1, se.fit=TRUE, newdata=newdat,  type="response"))
# predP<- cbind(predP, newdat[,1:2])
# head(predP)
# predP<-na.omit(predP)
# 
# summary(predP$fit)
# 
# coords.tmp<- cbind(predP$x, predP$y)
# predP.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predP), proj4string = CRS(mrc))
# pP<- rasterize(predP.spdf, bath.r , 'fit')
# eP<- rasterize(predP.spdf, bath.r , 'se.fit')
# image(pP, main="predicted abundance",  col = topo.colors(levels));plot(landT, add=TRUE)

#Ba
predBa<-as.data.frame(predict(Ba1, se.fit=TRUE, newdata=newdat,  type="response"))
predBa<- cbind(predBa, newdat[,1:2])
head(predBa)
predBa<-na.omit(predBa)
summary(predBa$fit)

coords.tmp<- cbind(predBa$x, predBa$y)
predBa.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predBa), proj4string = CRS(mrc))

pBa<- rasterize(predBa.spdf, bath.r , 'fit')
eBa<- rasterize(predBa.spdf, bath.r , 'se.fit')
image(pBa, main="predicted abundance",  col = topo.colors(levels));plot(landT, add=TRUE)
plot(scale(pBa))
maxValue(pBa)
minValue(pBa)

#Sr
predSr<-as.data.frame(predict(Sr1, se.fit=TRUE, newdata=newdat,  type="response"))
predSr<- cbind(predSr, newdat[,c(1:2)])
head(predSr)
predSr<-na.omit(predSr)

summary(predSr$fit)

coords.tmp<- cbind(predSr$x, predSr$y)
predSr.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predSr), proj4string = CRS(mrc))
pSr<- rasterize(predSr.spdf, bath.r , 'fit')
eSr<- rasterize(predSr.spdf, bath.r , 'se.fit')
image(pSr, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)

#Mn
predMn<-as.data.frame(predict(Mn1, se.fit=TRUE, newdata=newdat,  type="response"))
predMn<- cbind(predMn, newdat[,c(1:2)])
head(predMn)
predMn<-na.omit(predMn)

summary(predMn$fit)

coords.tmp<- cbind(predMn$x, predMn$y)
predMn.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predMn), proj4string = CRS(mrc))
pMn<- rasterize(predMn.spdf, bath.r , 'fit')
eMn<- rasterize(predMn.spdf, bath.r , 'se.fit')
image(pMn, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)

# #Zn
# predZn<-as.data.frame(predict(Zn1, se.fit=TRUE, newdata=newdat,  type="response"))
# predZn<- cbind(predZn, newdat[,c(1:2)])
# head(predZn)
# predZn<-na.omit(predZn)
# 
# summary(predZn$fit)
# 
# coords.tmp<- cbind(predZn$x, predZn$y)
# predZn.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predZn), proj4string = CRS(mrc))
# pZn<- rasterize(predZn.spdf, bath.r , 'fit')
# eZn<- rasterize(predZn.spdf, bath.r , 'se.fit')
# image(pZn, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)
# 

#Rb
predRb<-as.data.frame(predict(Rb1, se.fit=TRUE, newdata=newdat,  type="response"))
predRb<- cbind(predRb, newdat[,c(1:2)])
head(predRb)
predRb<-na.omit(predRb)

summary(predRb$fit)

coords.tmp<- cbind(predRb$x, predRb$y)
predRb.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predRb), proj4string = CRS(mrc))
pRb<- rasterize(predRb.spdf, bath.r , 'fit')
eRb<- rasterize(predRb.spdf, bath.r , 'se.fit')
image(pRb, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)

# 
# #Li
# predLi<-as.data.frame(predict(Li1, se.fit=TRUE, newdata=newdat,  type="response"))
# predLi<- cbind(predLi, newdat[,c(1:2)])
# head(predLi)
# predLi<-na.omit(predLi)
# 
# summary(predLi$fit)
# 
# coords.tmp<- cbind(predLi$x, predLi$y)
# predLi.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predLi), proj4string = CRS(mrc))
# pLi<- rasterize(predLi.spdf, bath.r , 'fit')
# eLi<- rasterize(predLi.spdf, bath.r , 'se.fit')
# image(pLi, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)


Sc
 predSc<-as.data.frame(predict(Sc1, se.fit=TRUE, newdata=newdat,  type="response"))
 predSc<- cbind(predSc, newdat[,c(1:2)])
 head(predSc)
 predSc<-na.omit(predSc)
# 
 summary(predSc$fit)
# 
 coords.tmp<- cbind(predSc$x, predSc$y)
 predSc.spdf<- SpatialPointsDataFrame(coords.tmp, data = data.frame(predSc), proj4string = CRS(mrc))
 pSc<- rasterize(predSc.spdf, bath.r , 'fit')
 eSc<- rasterize(predSc.spdf, bath.r , 'se.fit')
 image(pSc, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)


cut4<- aspect.r/aspect.r
plot(cut4)

pMn<- pMn*cut4
image(pMn, main="predicted abundance", col = topo.colors(levels));plot(landT, add=TRUE)


```

#write elemntal surfaces
```{r}


#elements
#pNa<- pNa*cut4
writeRaster(pNa, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelNa_414', format = 'raster', overwrite=T)

#pMg<- pMg*cut4
writeRaster(pMg, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelMg_414', format = 'raster', overwrite=T)

 #pP<- pP*cut4
 #writeRaster(pP, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelP_414', format = 'raster', overwrite=T)

#pBa<- pBa*cut4
writeRaster(pBa, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelBa_414', format = 'raster', overwrite=T)

#pSr<- pSr*cut4
writeRaster(pSr, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelSr_414', format = 'raster', overwrite=T)

#pMn<- pMn
writeRaster(pMn, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelMn_414', format = 'raster', overwrite=T)

# pZn<- pZn*cut4
# writeRaster(pZn, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelZn_414', format = 'raster', overwrite=T)

#pRb<- pRb*cut4
writeRaster(pRb, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelRb_414', format = 'raster', overwrite=T)

# pLi<- pLi*cut4
# writeRaster(pLi, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelLi_414', format = 'raster', overwrite=T)

# pSc<- pSc*cut4
# writeRaster(pSc, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/modelSc_414', format = 'raster', overwrite=T)



#errors
#eNa<- eNa*cut4
writeRaster(eNa, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelNa_414', format = 'raster', overwrite=T)

#eMg<- eMg*cut4
writeRaster(eMg, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelMg_414', format = 'raster', overwrite=T)

# eP<- eP*cut4
# writeRaster(eP, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelP_414', format = 'raster', overwrite=T)

#eBa<- eBa*cut4
writeRaster(eBa, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelBa_414', format = 'raster', overwrite=T)

#eSr<- eSr*cut4
writeRaster(eSr, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelSr_414', format = 'raster', overwrite=T)

#eMn<- eMn*cut4
writeRaster(eMn, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelMn_414', format = 'raster', overwrite=T)

# eZn<- eZn*cut4
# writeRaster(eZn, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelZn_414', format = 'raster', overwrite=T)

#eRb<- eRb*cut4
writeRaster(eRb, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelRb_414', format = 'raster', overwrite=T)

# eLi<- eLi*cut4
# writeRaster(eLi, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelLi_414', format = 'raster', overwrite=T)
# 
# eSc<- eSc*cut4
# writeRaster(eSc, file='F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelSc_414', format = 'raster', overwrite=T)



```



#CV data split
```{r}

# CV - Na
first.run <- TRUE

R=100
for (i in 1:R)
{
  # Split the data randomly into training data and testing data
  set.seed(i)
  
  lab<- c(1:nrow(datr))
  trainIndex <- createDataPartition(lab, p = 0.75,
                                  list = FALSE,
                                  times = 1)
  train <- datr[ trainIndex,]
  test  <- datr[-trainIndex,]
  
  
  # Use the train dataset and the final model to make predictions for the test data
  Nat<-gam(Na~   s(x, y, bs='so', xt =list(bnd=bound)),
         data = train, family = gaussian, knots=knots)
 
  preds <- as.vector(predict(Nat, newdata = test,
                                 type = "response"))
  
 #Bind the predictions to the test dataset
  N.preds <- cbind(test, 'preds'=preds)
  
  if (first.run)
  {
    N.spearmans <- N.preds
    
  } else {
    N.spearmans <- rbind(N.spearmans, N.preds)
  }
  
  
  if (first.run)
  {
    Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
    
    first.run <- FALSE
  } else {
    Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
  }
}

## Plot and stats
Tmeans<- aggregate(datr$Na, by=list(datr$Haul_id), FUN=mean)[,2]
allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)

plot(Tmeans, allPmeans, pch=18, cex=3)
for(i in 2:R){
  points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
}
points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')

cor.test(rank(Tmeans),rank(allPmeans), method='spearman')

  
#Mg



first.run <- TRUE

R=100
for (i in 1:R)
{
  # Split the data randomly into training data and testing data
  set.seed(i)
  
  lab<- c(1:nrow(datr))
  trainIndex <- createDataPartition(lab, p = 0.75,
                                  list = FALSE,
                                  times = 1)
  train <- datr[ trainIndex,]
  test  <- datr[-trainIndex,]
  
  
  # Use the train dataset and the final model to make predictions for the test data
  Mgt<- gam(Mg~   s(x, y, bs='so', xt =list(bnd=bound)),
           data = train, family = gaussian, knots=knots)
 
  preds <- as.vector(predict(Mgt, newdata = test,
                                 type = "response"))
  
 #Bind the predictions to the test dataset
  N.preds <- cbind(test, 'preds'=preds)
  
  if (first.run)
  {
    N.spearmans <- N.preds
    
  } else {
    N.spearmans <- rbind(N.spearmans, N.preds)
  }
  
  
  if (first.run)
  {
    Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
    
    first.run <- FALSE
  } else {
    Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
  }
}

## Plot and stats
Tmeans<- aggregate(datr$Mg, by=list(datr$Haul_id), FUN=mean)[,2]
allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)

plot(Tmeans, allPmeans, pch=18, cex=3)
for(i in 2:R){
  points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
}
points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')

cor.test(rank(Tmeans),rank(allPmeans), method='spearman')

#P


# 
# first.run <- TRUE
# 
# R=100
# for (i in 1:R)
# {
#   # Split the data randomly into training data and testing data
#   set.seed(i)
#   
#   lab<- c(1:nrow(datr))
#   trainIndex <- createDataPartition(lab, p = 0.75,
#                                   list = FALSE,
#                                   times = 1)
#   train <- datr[ trainIndex,]
#   test  <- datr[-trainIndex,]
#   
#   
#   # Use the train dataset and the final model to make predictions for the test data
#   Mg1<- gam(P~   s(x, y, bs='so', xt =list(bnd=bound)),
#            data = train, family = gaussian, knots=knots)
#  
#   preds <- as.vector(predict(P1, newdata = test,
#                                  type = "response"))
#   
#  #Bind the predictions to the test dataset
#   N.preds <- cbind(test, 'preds'=preds)
#   
#   if (first.run)
#   {
#     N.spearmans <- N.preds
#     
#   } else {
#     N.spearmans <- rbind(N.spearmans, N.preds)
#   }
#   
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# ## Plot and stats
# Tmeans<- aggregate(datr$P, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans, allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
#   

  
  
#Ba  


first.run <- TRUE

R=100
for (i in 1:R)
{
  # Split the data randomly into training data and testing data
  set.seed(i)
  
   lab<- c(1:nrow(datr))
   trainIndex <- createDataPartition(lab, p = 0.75,
                                   list = FALSE,
                                   times = 1)
   train <- datr[ trainIndex,]
   test  <- datr[-trainIndex,]
  
  #s=sampling::strata(datr,strataname=c("Haul_id"),size=rep(1, length(unique(datr$Haul_id))), method="srswor")
 # test<- getdata(datr,s)
  trainIndex<-as.numeric(rownames(test))
  #train<- datr[-trainIndex,]
  
  # Use the train dataset and the final model to make predictions for the test data
  Bat<-gam(Ba~   s(x, y, bs='so', xt =list(bnd=bound)),
            data = train, family = Gamma, knots=knots)
 
  preds <- as.vector(predict(Bat, newdata = test,
                                 type = "response"))
  
 #Bind the predictions to the test dataset
  N.preds <- cbind(test, 'preds'=preds)
  
  if (first.run)
  {
    N.spearmans <- N.preds
    
  } else {
    N.spearmans <- rbind(N.spearmans, N.preds)
  }
  
  
  if (first.run)
  {
    Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
    
    first.run <- FALSE
  } else {
    Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
  }
}

## Plot and stats
Tmeans<- aggregate(datr$Ba, by=list(datr$Haul_id), FUN=mean)[,2]
allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)

plot(Tmeans, allPmeans, pch=18, cex=3)
for(i in 2:R){
  points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
}
points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')

cor.test(rank(Tmeans),rank(allPmeans), method='spearman')

#Sr


first.run <- TRUE

R=100
for (i in 1:R)
{
  # Split the data randomly into training data and testing data
  set.seed(i)
  
  lab<- c(1:nrow(datr))
  trainIndex <- createDataPartition(lab, p = 0.75,
                                  list = FALSE,
                                  times = 1)
  train <- datr[ trainIndex,]
  test  <- datr[-trainIndex,]
  
  
  # Use the train dataset and the final model to make predictions for the test data
  Srt<- gam(Sr~   s(x, y, bs='so', xt =list(bnd=bound)),
          data = train, family = gaussian, knots=knots)
 
  preds <- as.vector(predict(Srt, newdata = test,
                                 type = "response"))
  
 #Bind the predictions to the test dataset
  N.preds <- cbind(test, 'preds'=preds)
  
  if (first.run)
  {
    N.spearmans <- N.preds
    
  } else {
    N.spearmans <- rbind(N.spearmans, N.preds)
  }
  
  
  if (first.run)
  {
    Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
    
    first.run <- FALSE
  } else {
    Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
  }
}

## Plot and stats
Tmeans<- aggregate(datr$Sr, by=list(datr$Haul_id), FUN=mean)[,2]
allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)

plot(Tmeans, allPmeans, pch=18, cex=3)
for(i in 2:R){
  points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
}
points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')

cor.test(rank(Tmeans),rank(allPmeans), method='spearman')


#Mn - try both of these
#Mn1<-gam(MnCor~   s(x, y, bs='so', xt =list(bnd=bound)),
#         data = datr, family = gaussian, knots=knots)

 
#Mn1<-gam(MnCor~    s(depth, bs='cr', k =6)+ s(sal, bs='cr', k =6),
        #data = datr, family = gaussian, knots=knots)


first.run <- TRUE

R=100
for (i in 1:R)
{
  # Split the data randomly into training data and testing data
  set.seed(i)
  
  lab<- c(1:nrow(datr))
  trainIndex <- createDataPartition(lab, p = 0.75,
                                  list = FALSE,
                                  times = 1)
  train <- datr[ trainIndex,]
  test  <- datr[-trainIndex,]
  
  
  # Use the train dataset and the final model to make predictions for the test data
 Mnt<-gam(Mn~   s(x, y, bs='so', xt =list(bnd=bound)),
         data = train, family = Gamma, knots=knots)
 
  preds <- as.vector(predict(Mnt, newdata = test,
                                 type = "response"))
  
 #Bind the predictions to the test dataset
  N.preds <- cbind(test, 'preds'=preds)
  
  if (first.run)
  {
    N.spearmans <- N.preds
    
  } else {
    N.spearmans <- rbind(N.spearmans, N.preds)
  }
  
  
  if (first.run)
  {
    Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
    
    first.run <- FALSE
  } else {
    Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
  }
}

## Plot and stats
Tmeans<- aggregate(datr$Mn, by=list(datr$Haul_id), FUN=mean)[,2]
allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)

plot(Tmeans, allPmeans, pch=18, cex=3)
for(i in 2:R){
  points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
}
points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')

cor.test(rank(Tmeans),rank(allPmeans), method='spearman')

#Zn

# first.run <- TRUE
# 
# R=100
# for (i in 1:R)
# {
#   # Split the data randomly into training data and testing data
#   set.seed(i)
#   
#   lab<- c(1:nrow(datr))
#   trainIndex <- createDataPartition(lab, p = 0.80,
#                                   list = FALSE,
#                                   times = 1)
#   train <- datr[ trainIndex,]
#   test  <- datr[-trainIndex,]
#   
#   
#   # Use the train dataset and the final model to make predictions for the test data
#   Zn1<-gam(Zn~   s(x, y, bs='so', xt =list(bnd=bound)),
#          data = train, family = gaussian, knots=knots)
#  
#   preds <- as.vector(predict(Zn1, newdata = test,
#                                  type = "response"))
#   
#  #Bind the predictions to the test dataset
#   N.preds <- cbind(test, 'preds'=preds)
#   
#   if (first.run)
#   {
#     N.spearmans <- N.preds
#     
#   } else {
#     N.spearmans <- rbind(N.spearmans, N.preds)
#   }
#   
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# ## Plot and stats
# Tmeans<- aggregate(datr$Zn, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans, allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# 
# #Cu
# 
# 
# first.run <- TRUE
# 
# R=100
# for (i in 1:R)
# {
#   # Split the data randomly into training data and testing data
#   set.seed(i)
#   
#   lab<- c(1:nrow(datr))
#   trainIndex <- createDataPartition(lab, p = 0.80,
#                                   list = FALSE,
#                                   times = 1)
#   train <- datr[ trainIndex,]
#   test  <- datr[-trainIndex,]
#   
#   
#   # Use the train dataset and the final model to make predictions for the test data
#   Cu1<-gam(Cu~   s(x, y, bs='so', xt =list(bnd=bound)),
#           data = train, family = gaussian, knots=knots)
#  
#   preds <- as.vector(predict(Cu1, newdata = test,
#                                  type = "response"))
#   
#  #Bind the predictions to the test dataset
#   N.preds <- cbind(test, 'preds'=preds)
#   
#   if (first.run)
#   {
#     N.spearmans <- N.preds
#     
#   } else {
#     N.spearmans <- rbind(N.spearmans, N.preds)
#   }
#   
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# ## Plot and stats
# Tmeans<- aggregate(datr$Cu, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans, allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 

#Rb



first.run <- TRUE

R=100
for (i in 1:R)
{
  # Split the data randomly into training data and testing data
  set.seed(i)
  
  lab<- c(1:nrow(datr))
  trainIndex <- createDataPartition(lab, p = 0.75,
                                  list = FALSE,
                                  times = 1)
  train <- datr[ trainIndex,]
  test  <- datr[-trainIndex,]
  
  
  # Use the train dataset and the final model to make predictions for the test data
  Rbt<-gam(Rb~   s(x, y, bs='so', xt =list(bnd=bound)) ,
            data = train, family = Gamma, knots=knots)
 
  preds <- as.vector(predict(Rbt, newdata = test,
                                 type = "response"))
  
 #Bind the predictions to the test dataset
  N.preds <- cbind(test, 'preds'=preds)
  
  if (first.run)
  {
    N.spearmans <- N.preds
    
  } else {
    N.spearmans <- rbind(N.spearmans, N.preds)
  }
  
  
  if (first.run)
  {
    Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
    
    first.run <- FALSE
  } else {
    Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
  }
}

## Plot and stats
Tmeans<- aggregate(datr$Rb, by=list(datr$Haul_id), FUN=mean)[,2]
allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)

plot(Tmeans, allPmeans, pch=18, cex=3)
for(i in 2:R){
  points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
}
points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')

cor.test(rank(Tmeans),rank(allPmeans), method='spearman')



#Li
# 
# 
# first.run <- TRUE
# 
# R=100
# for (i in 1:R)
# {
#   # Split the data randomly into training data and testing data
#   set.seed(i)
#   
#   lab<- c(1:nrow(datr))
#   trainIndex <- createDataPartition(lab, p = 0.80,
#                                   list = FALSE,
#                                   times = 1)
#   train <- datr[ trainIndex,]
#   test  <- datr[-trainIndex,]
#   
#   
#   # Use the train dataset and the final model to make predictions for the test data
#   Li1<-gam(Li~   s(x, y, bs='so', xt =list(bnd=bound)),
#             data = train, family = gaussian, knots=knots)
#  
#   preds <- as.vector(predict(Li1, newdata = test,
#                                  type = "response"))
#   
#  #Bind the predictions to the test dataset
#   N.preds <- cbind(test, 'preds'=preds)
#   
#   if (first.run)
#   {
#     N.spearmans <- N.preds
#     
#   } else {
#     N.spearmans <- rbind(N.spearmans, N.preds)
#   }
#   
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# ## Plot and stats
# Tmeans<- aggregate(datr$Li, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans, allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')

#Sc
 
#  
#  first.run <- TRUE
# 
# R=100
# for (i in 1:R)
# {
#   # Split the data randomly into training data and testing data
#   set.seed(i)
#   
#   lab<- c(1:nrow(datr))
#   trainIndex <- createDataPartition(lab, p = 0.85,
#                                   list = FALSE,
#                                   times = 1)
#   train <- datr[ trainIndex,]
#   test  <- datr[-trainIndex,]
#   
#   
#   # Use the train dataset and the final model to make predictions for the test data
#   Sc1<-gam(Sc~   s(x, y, bs='so', xt =list(bnd=bound))+ s(chl, bs='cr', k =6),
#           data = train, family = Gamma, knots=knots)
#  
#   preds <- as.vector(predict(Sc1, newdata = test,
#                                  type = "response"))
#   
#  #Bind the predictions to the test dataset
#   N.preds <- cbind(test, 'preds'=preds)
#   
#   if (first.run)
#   {
#     N.spearmans <- N.preds
#     
#   } else {
#     N.spearmans <- rbind(N.spearmans, N.preds)
#   }
#   
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(N.spearmans$preds, by=list(N.spearmans$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# ## Plot and stats
# Tmeans<- aggregate(datr$Sc, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans, allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=80), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3, col='yellow')
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# 

```


```{r}

#  # CV if its not a Soap film smoother
# ##Na
# 
# Na2<- gam(Na~ s(lat, k=6), data=datr)
# Pmeans<-NA
# first.run=TRUE
# 
# R=2
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Na1.val <- CVgam(formula= Na2$formula,  data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Na1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Na1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$Na, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=60), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# 
# ##Mg
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Mg1.val <- CVgam(formula=Mg1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Mg1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Mg1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$Mg, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=16), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# 
# 
# ##Ba
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Ba1.val <- CVgam(formula=Ba1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Ba1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Ba1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$BaCor, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=16), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# 
# ##Sr
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Sr1.val <- CVgam(formula=Sr1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Sr1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Sr1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$Sr, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=2), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# ##Mn
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Mn1.val <- CVgam(formula=Mn1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Mn1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Mn1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$MnCor, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=6), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# ##Cu
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Cu1.val <- CVgam(formula=Cu1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Cu1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Cu1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$CuT, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=16), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# 
# ##Rb
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Rb1.val <- CVgam(formula=Rb1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Rb1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Rb1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$Rb, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=6), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# ##Li
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Li1.val <- CVgam(formula=Li1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Li1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Li1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$Li, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=16), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman')
# 
# ##Sc
# Pmeans<-NA
# first.run=TRUE
# for(i in 1:R){
#   foldnum <- sample(1:10, size=nrow(datr), replace=TRUE)
#   Sc1.val <- CVgam(formula=Sc1$formula, data = datr, debug.level = 0, printit = FALSE, method = "ML",cvparts = foldnum, gamma = 1)
#   
#   if (first.run)
#   {
#     Pmeans<- aggregate(Sc1.val$fitted, by=list(datr$Haul_id), FUN=mean)
#     
#     first.run <- FALSE
#   } else {
#     Pmeans <- cbind(Pmeans, aggregate(Sc1.val$fitted, by=list(datr$Haul_id), FUN=mean)[,2])
#   }
# }
# 
# 
# Tmeans<- aggregate(datr$Sc, by=list(datr$Haul_id), FUN=mean)[,2]
# allPmeans<- apply(Pmeans[,-1], MARGIN=1,FUN=mean)
# 
# plot(Tmeans,allPmeans, pch=18, cex=3)
# for(i in 2:R){
#   points(jitter(Tmeans, factor=3), Pmeans[,i], col='blue')
# }
# points(Tmeans,allPmeans, pch=18, cex=3)
# 
# cor.test(rank(Tmeans),rank(allPmeans), method='spearman'))

```

# covariance check
```{r}


##try corriplot
rNa<-sample(Na1$residuals, size =112, replace =FALSE)
rMg<-sample(Mg1$residuals, size =112, replace =FALSE)
rP<-sample(P1$residuals, size =112, replace =FALSE)
rBa<-sample(Ba1$residuals, size =112, replace =FALSE)
rSr<-sample(Sr1$residuals, size =112, replace =FALSE)
rMn<-sample(Mn1$residuals, size =112, replace =FALSE)
rZn<-sample(Zn1$residuals, size =112, replace =FALSE)
rRb<-sample(Rb1$residuals, size =112, replace =FALSE)
rLi<-sample(Li1$residuals, size =112, replace =FALSE)

resid<- cbind(rNa, rMg, rP, rBa, rSr, rMn, rZn, rRb, rLi)
colnames(resid)<- c("Na", "Mg", "P",  "Ba", "Sr", "Mn", "Zn" ,"Rb", "Li")
head(resid)
cors<- cor(resid)

col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582",
"#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE",
"#4393C3", "#2166AC", "#053061"))



corrplot(cors, method='color', type='upper', diag=FALSE, order='original', col=col2(100), addCoef.col = "grey")


```


# Plot data and layers
```{r}

################################# basic background maps of land and sea #####################################

#### use shape files generated from 'make_extentshp' code use rgdal to read it in to get projections
#scot<- readOGR(dsn="/Volumes/PHD/R_script/SDM", layer="scot")
base<- readOGR(dsn='F:/R_script/SDM', layer="full")
# base<- readOGR(dsn='/Volumes/PHD/R_script/SDM', layer="full")

plot(base)
base<- crop(base, full.ext)

land<- readOGR(dsn= "F:/R_script/SDM/my_layers_collection", layer ='Britain_Proj_Dist')
#land<- readOGR(dsn= "/Volumes/PHD/R_script/SDM/my_layers_collection", layer ='Britain_Proj_Dist')
land<- spTransform(land, CRS(WGS84))
land<- crop(land, full.ext)


plot(base, col ='cornflowerblue')
plot(land, col='cornsilk', add=T)

###################################
### apply projection to sea area and land from above
landT<- spTransform(land, CRS(mrc))
baseT<- spTransform(base, CRS(mrc))

#read in data layers for speed
pNa<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelNa_414.grd')
eNa<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelNa_414')
pMg<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelMg_414.grd')
eMg<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelMg_414')
pP<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelP_414.grd')
eP<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelP_414')
pBa<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelBa_414.grd')
eBa<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelBa_414')
pSr<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelSr_414.grd')
eSr<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelSr_414')
pMn<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelMn_414.grd')
eMn<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelMn_414')
pZn<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelZn_414.grd')
eZn<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelZn_414')
pRb<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelRb_414.grd')
eRb<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelRb_414')
pLi<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/modelLi_414.grd')
eLi<- raster('F:/R_script/Microchemistry/elemental_maps/elem_layers/er_modelLi_414')



##Temp cols
display.brewer.all()

area.shades<- brewer.pal(9,'Set1')
#spec<- brewer.pal(11,'Spectral')
spec<-colorRampPalette(rev(brewer.pal(11,'Spectral')))
dave.heat<- colorRampPalette(rev(brewer.pal(9,'Blues')[4:9]))


######## plot environmental data
L <- parse(text = paste(c(8,6,4), "*degree ~W", sep = "")) # longitudes
LN<- parse(text = paste(c(52:60), "*degree ~N", sep = "")) #lats

# extract coords for the tick marks
longs<- c(-2.5,-4,-6,-8,-10 )
lats<- c(54.5, 54.5, 54.5, 54.5, 54.5)
S <- SpatialPoints(cbind(longs,lats), CRS(WGS84))

ST<- spTransform(S, CRS(mrc))
plot(ST)
coordinates(ST)

longs<- c(-6.5,-6.5,-6.5,-6.5,-6.5, -6.5, -6.5, -6.5, -6.5 )
lats<- c(52, 53, 54, 55, 56, 57, 58, 59, 60)
S <- SpatialPoints(cbind(longs,lats), CRS(WGS84))

ST<- spTransform(S, CRS(mrc))
plot(ST)
coordinates(ST)


######## plot element layers

#Na
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(pNa, col = spec(1000), zlim= c(minValue(pNa),maxValue(pNa)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(pNa, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Na- er
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(eNa, col = spec(1000), zlim= c(minValue(eNa),maxValue(eNa)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(scale(eNa, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#####Mg

#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(pMg, col =spec(1000), zlim= c(minValue(pMg),maxValue(pMg)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(pMg, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Mg- er
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(eMg, col = spec(1000), zlim= c(minValue(eMg),maxValue(eMg)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)


#Legend
plot(scale(eMg, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

 #P
#par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(pP, col = spec(1000), zlim= c(minValue(pP),maxValue(pP)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(pP, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))
# 
# #P- er
# #par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(eP, col = spec(1000), zlim= c(minValue(eP),maxValue(eP)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(scale(eP, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Ba
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(pBa, col = spec(1000), zlim= c(minValue(pBa),maxValue(pBa)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(pBa, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Ba- er
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(eBa, col = spec(1000), zlim= c(minValue(eBa),maxValue(eBa)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(scale(eBa, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))



#Sr


#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(pSr, col = spec(1000), zlim= c(minValue(pSr),maxValue(pSr)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(pSr, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Sr- er
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(eSr, col = spec(1000), zlim= c(minValue(eSr),maxValue(eSr)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(scale(eSr, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))


###Mn


#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(pMn, col = spec(1000), zlim= c(minValue(pMn),maxValue(pMn)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(pMn, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Mn- er
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(eMn, col = spec(1000), zlim= c(minValue(eMn),maxValue(eMn)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(scale(eMn, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))



###Zn


#par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(pZn, col = spec(1000), zlim= c(minValue(pZn),maxValue(pZn)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(round(pZn,3), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))
# 
# #Cu- er
# #par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(eZn, col = spec(1000), zlim= c(minValue(eZn),maxValue(eZn)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(round(eZn,3), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))
# 

###Rb


#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(pRb, col = spec(1000), zlim= c(minValue(pRb),maxValue(pRb)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(pRb, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))

#Rb- er
#par(mfrow=c(2,2))
par(mar = c(5,6,4,2))
image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
image(eRb, col = spec(1000), zlim= c(minValue(eRb),maxValue(eRb)), add=T)
plot(landT, add =T, col = 'cornsilk3')
plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)

axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
abline(h=-1057535.2)
axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
#axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)

#Legend
plot(scale(eRb, center=F, scale=F), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))



###Li


#par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(pLi, col = spec(1000), zlim= c(minValue(pLi),maxValue(pLi)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(pLi, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))
# 
# #Li- er
# #par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(eLi, col = spec(1000), zlim= c(minValue(eLi),maxValue(eLi)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(eLi, horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))


###Sc


#par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(pSc, col = spec(1000), zlim= c(minValue(pSc),maxValue(pSc)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(scale(pSc), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))
# 
# #Sc- er
# #par(mfrow=c(2,2))
# par(mar = c(5,6,4,2))
# image(pNa, col = 'white', xaxt='n', yaxt='n',xlim=c(-1057535.2,-278298.7), ylim= c(6800125,8399738), xlab=NA, ylab=NA) ###use image to keep plot in same 'window' for plotting - plot() extends plotting area
# image(eSc, col = spec(1000), zlim= c(minValue(eSc),maxValue(eSc)), add=T)
# plot(landT, add =T, col = 'cornsilk3')
# plot(chem.spdfT, add=T, pch=19, col='black', cex=2.5)
# 
# axis(1, at=c( -890555.9, -667916.9, -445278.0), L, lwd.ticks=1, cex.axis=2, padj=0.8)
# abline(h=-1057535.2)
# axis(2, at=c(6800125, 6982998, 7170156, 7361866, 7558416, 7760119, 7967318, 8180387, 8399738), labels=LN, lwd.ticks=1, pos=-1057535.2, las=1,cex.axis=2)
# axis(4, at=c(6800125,8399738), labels=NA, lwd.ticks=0, pos=-278298.7)
# #axis(3, at=c(-1066000,-333000), labels=NA, lwd.ticks=0, pos=8404000)
# 
# #Legend
# plot(scale(eSc, center=T, scale=cellStats(pSc, 'sd')), horizontal=F,  smallplot= c(0.6,0.62,0.2,0.8), col = spec(1000),legend.only=TRUE,  axis.args = list(cex.axis = 2))


```